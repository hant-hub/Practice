#include <stdio.h>
#include <stdlib.h>
#include <vulkan/vulkan_core.h>
#define GLFW_INCLUDE_VULKAN
#include <GLFW/glfw3.h>


typedef struct {
    GLFWwindow* window;
    VkSurfaceKHR surface;
    VkInstance instance;
    VkPhysicalDevice deviceP;
    VkDevice deviceL;
} VulkanContext;

static VulkanContext vk = {0};

const char* validation[] = {
    "VK_LAYER_KHRONOS_validation"
};

const char* Extensions[] = {
    VK_KHR_SWAPCHAIN_EXTENSION_NAME
};


int main() {
    glfwInit();
    glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);
    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);

    vk.window = glfwCreateWindow(900, 600, "Day 3 Practice", NULL, NULL);



    while (!glfwWindowShouldClose(vk.window)) {
        glfwPollEvents();
    }

    glfwDestroyWindow(vk.window);
    glfwTerminate();
    return 0;
}


void InitVulkan() {
    VkApplicationInfo appInfo = {
        .sType = VK_STRUCTURE_TYPE_APPLICATION_INFO,
        .pApplicationName = "Day 3 Practice",
        .pEngineName = "No Engine",
        .apiVersion = VK_MAKE_VERSION(1, 0, 0),
        .engineVersion = VK_MAKE_VERSION(1, 0, 0),
    };


    uint32_t glfwExtensionCount;
    const char** glfwExtensions = glfwGetRequiredInstanceExtensions(&glfwExtensionCount);
    VkInstanceCreateInfo instanceInfo = {
        .sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
        .pApplicationInfo = &appInfo,
        .enabledLayerCount = 1,
        .ppEnabledLayerNames = validation,
        .enabledExtensionCount = glfwExtensionCount,
        .ppEnabledExtensionNames = glfwExtensions,
    };

    if (vkCreateInstance(&instanceInfo, NULL, &vk.instance) != VK_SUCCESS) {
        printf("failed to create Instance\n");
        exit(1);
    }

    if (glfwCreateWindowSurface(vk.instance, vk.window, NULL, &vk.surface) != VK_SUCCESS) {
        printf("Failed to create surface\n");
        exit(1);
    }

    {
        uint32_t deviceCount;
        vkEnumeratePhysicalDevices(vk.instance, &deviceCount, NULL);
        VkPhysicalDevice devices[deviceCount];
        vkEnumeratePhysicalDevices(vk.instance, &deviceCount, devices);

        for (int i = 0; i < deviceCount; i++) {
            VkPhysicalDeviceProperties props;
            vkGetPhysicalDeviceProperties(devices[i], &props);

            if (props.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU) {
                vk.deviceP = devices[i];
                break;
            }
        }


        uint32_t graphics, present;
        
        uint32_t queueCount;
        vkGetPhysicalDeviceQueueFamilyProperties(vk.deviceP, &queueCount, NULL);
        VkQueueFamilyProperties queueProps[queueCount];
        vkGetPhysicalDeviceQueueFamilyProperties(vk.deviceP, &queueCount, queueProps);

        for (int i = 0; i < queueCount; i++) {
            if (queueProps[i].queueFlags & VK_QUEUE_GRAPHICS_BIT) {
                graphics = i;
                break;
            }
        }
        for (int i = 0; i < queueCount; i++) {
            VkBool32 supported;
            vkGetPhysicalDeviceSurfaceSupportKHR(vk.deviceP, i, vk.surface, &supported);
            if (supported) {
                present = i;
                break;
            }
        }

        float priority = 1.0f;

        VkDeviceQueueCreateInfo queueInfo = {
            .sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
            .queueCount = 1,
            .pQueuePriorities = &priority,
            .queueFamilyIndex = graphics,
        };

        VkDeviceCreateInfo deviceInfo = {
            .sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
        };

    }

}

void DestroyContext() {
    vkDestroySurfaceKHR(vk.instance, vk.surface, NULL);
    vkDestroyInstance(vk.instance, NULL);
}
